**Requirements Document for Atlas**

**Версия 0.2 (Черновик на основе обновленных данных)**

**Подготовлено:** [Ваше Имя/Команда] *(Пожалуйста, укажите авторов)*
**На основе данных, предоставленных:** [Имя пользователя], [Дата обновления]

**Ключевые слова:** аутентификация, авторизация, OAuth2.0, интеграция API, управление пользователями, безопасность веб-приложений, SaaS, iframe, postMessage, FastAPI, React, PostgreSQL, Docker.

---

**(Предварительное) Оглавление**

1.  **Цель проекта**
2.  **Краткое описание предметной области**
3.  **Технико-экономическое обоснование и основные решения**
    3.1. Цели, задачи и ограничения
    3.2. Предварительная архитектура
    3.3. Технологический стек
        3.3.1. Интероперабельность (Interoperability)
        3.3.2. Масштабируемость (Scalability)
    3.4. Методология прототипирования
    3.5. XXXOps (DevOps, SecOps)
4.  **Спецификация требований к программному обеспечению (SRS)**
5.  **Концептуальное моделирование**
    5.1. Описание процесса построения инфологической модели
        5.1.1. Диаграмма "сущность-связь" (ERD) с комментариями (PlantUML)
    5.2. Пользовательские сценарии (User journeys)
6.  **Логическое моделирование данных**
    6.1. Описание процесса перехода к даталогической (реляционной) модели
        6.1.1. Таблично-ссылочная диаграмма (TRD) с комментариями
7.  **Логическое моделирование процессов**
    7.1. Основные сценарии (BPMN)
    7.2. Частичная диаграмма потоков данных (DFD или аналоги)
8.  **Физическое моделирование данных**
    8.1. Диаграмма схемы БД (с типами данных и ссылочной целостностью)
    8.2. Дополнительные механизмы обеспечения целостности данных
    8.3. DDL-код БД
9.  **Построение приложения**
    9.1. Бизнес-логика тестового приложения
    9.2. Техническое описание тестового приложения
    9.3. UI-решения
    9.4. Примеры редактирования данных в БД
    9.5. Запросы и отчеты (включая SQL)
    9.6. Артефакты юзабилити-тестирования
10. **Результаты функционального тестирования**
11. **Результаты юзабилити-тестирования**
12. **Заключение**
13. **Приложения (например, Ссылки)**

---

**1. Цель проекта**

Разработка облачного сервиса **Atlas**, предоставляющего разработчикам платформу для упрощенной интеграции, настройки и управления системами аутентификации и авторизации в их веб-приложениях. Сервис нацелен на снижение сложности и времени разработки, связанных с реализацией функций входа, регистрации, поддержки OAuth2.0 (включая российских провайдеров) и управления пользователями.

**2. Краткое описание предметной области**

Проект относится к области управления идентификацией и доступом (Identity and Access Management, IAM), аутентификации как услуги (Authentication as a Service, AaaS) и инструментов для разработчиков (Developer Tools). Предметная область включает:
*   Механизмы аутентификации (парольная, через OAuth2.0/OpenID Connect).
*   Протоколы OAuth2.0 и OpenID Connect.
*   Управление пользовательскими сессиями (JWT).
*   Ролевые модели доступа (RBAC).
*   Безопасность веб-приложений (хеширование паролей, CORS, HTTPS).
*   Встраивание интерфейсов (iframe, postMessage).

**3. Технико-экономическое обоснование и основные решения**

**3.1. Цели, задачи и ограничения**

*   **Цели:**
    *   Создать масштабируемый и безопасный сервис Atlas.
    *   Упростить процесс интеграции аутентификации для разработчиков.
    *   Обеспечить поддержку популярных OAuth2.0 провайдеров, включая российских (Яндекс.ID).
    *   Предоставить удобный интерфейс для управления пользователями и проектами.
    *   Занять нишу на российском рынке IAM-решений для малых и средних проектов.
*   **Задачи:**
    *   Разработать REST API бэкенда (FastAPI).
    *   Разработать веб-интерфейс фронтенда (React) для встраиваемых форм и панели управления.
    *   Реализовать механизм безопасного встраивания через iframe и postMessage.
    *   Интегрировать OAuth2.0 провайдеров (Google, Yandex).
    *   Реализовать систему управления пользователями и ролями.
    *   Настроить инфраструктуру для развертывания (Docker).
    *   Провести тестирование (функциональное, юзабилити, нагрузочное).
*   **Ограничения:**
    *   Проект разрабатывается в рамках академического процесса (курсовой проект, магистерская диссертация).
    *   Первоначальная версия (прототип) имеет 2 OAuth провайдера (Google, Yandex).
    *   Нет возможности добавления других администраторов (владельцев проектов Atlas) в один проект.
    *   Ограниченные вычислительные мощности для развертывания прототипа.
    *   Зависимость от доступности и условий API сторонних OAuth-провайдеров.

**3.2. Предварительная архитектура**

*   **Компоненты:**
    *   **Бэкенд:** Монолитное (на данном этапе, в будущем планируется переход на микросервисную архитектуру) приложение на FastAPI, отвечающее за REST API, логику аутентификации, взаимодействие с БД и OAuth-провайдерами.
    *   **Фронтенд:** Приложение на React JS, предоставляющее:
        *   Панель управления для администраторов Atlas (владельцев проектов).
        *   Интерфейс для получения данных, необходимых для встраивания форм (например, ID проекта).
    *   **База данных:** Реляционная СУБД PostgreSQL для хранения данных администраторов Atlas (`admins`), их проектов (`projects`) и конечных пользователей (`users`), зарегистрировавшихся через Atlas для конкретного проекта.
*   **Взаимодействие:**
    *   Фронтенд (панель управления) взаимодействует с бэкендом через REST API.
    *   Интеграция встраиваемых форм Atlas в сторонние приложения осуществляется через `<iframe>` с обменом данными по `postMessage`.
*   **Развертывание:** Контейнеризация с использованием Docker и Docker Compose. Проксирование запросов через Nginx.

    *   **[Необходима информация]:** *Есть ли более детальная схема архитектуры (например, с указанием основных модулей бэкенда, взаимодействием с внешними системами)?*

**3.3. Технологический стек**

*   **Бэкенд:** Python, FastAPI, PostgreSQL, SQLAlchemy (с Alembic для миграций), Pydantic, python-jose (для JWT), Bcrypt.
*   **Фронтенд:** JavaScript, React JS, Redux (Redux Toolkit), Axios, Ant Design, React Router.
*   **Инфраструктура:** Docker, Docker Compose, Nginx.
*   **Тестирование:** Pytest (для бэкенда), отдельное веб-приложение (React) для ручного и потенциально автоматизированного E2E-тестирования встраиваемых форм.

    **3.3.1. Интероперабельность (Interoperability)**
    *   Обеспечивается через стандартизированный REST API (FastAPI автоматически генерирует OpenAPI/Swagger документацию).
    *   Использование стандартных протоколов OAuth2.0/OpenID Connect.
    *   Механизм встраивания `iframe` + `postMessage` является веб-стандартом.

    **3.3.2. Масштабируемость (Scalability)**
    *   Горизонтальное масштабирование бэкенд-сервисов возможно благодаря контейнеризации (Docker) и асинхронной природе FastAPI.
    *   Nginx может использоваться для балансировки нагрузки.
    *   PostgreSQL поддерживает репликацию для масштабирования чтения.

**3.4. Методология прототипирования**

*   Проект начинался как MVP (минимально жизнеспособный продукт) в рамках курсового проекта.
*   Были реализованы основные функции: регистрация/логин администраторов Atlas (включая OAuth), создание/управление проектами, базовая система ролей для конечных пользователей, встраиваемые формы для конечных пользователей (логин/регистрация через email и OAuth).
*   Дальнейшее развитие планируется в рамках магистерской диссертации с переработкой архитектуры (возможно, микросервисы) и расширением функционала.

    *   **[Необходима информация]:** *Какая конкретно методология разработки использовалась (Agile, Scrum, Waterfall)? Как собирались требования и обратная связь на этапе MVP?*

**3.5. XXXOps (DevOps, SecOps)**

*   **DevOps:**
    *   Используется Docker и Docker Compose для создания воспроизводимой среды разработки и упрощения развертывания.
    *   Планируется использование CI/CD (например, GitHub Actions) для автоматизации сборки, тестирования и развертывания.
*   **SecOps:**
    *   Хеширование паролей (Bcrypt).
    *   Защита JWT (короткий срок жизни access token, использование refresh token, хранение секретов JWT и OAuth в переменных окружения).
    *   Настройка CORS для API.
    *   Использование HTTPS (через Nginx).
    *   Валидация входных данных на уровне API (Pydantic).
    *   Реализован Rate Limiting для эндпоинтов аутентификации.

    *   **[Необходима информация]:** *Настроены ли системы логирования и мониторинга? Есть ли конкретный план CI/CD? Проводились ли аудиты безопасности или статическое/динамическое сканирование кода?*

**4. Спецификация требований к программному обеспечению (SRS)**

*   **Функциональные требования:**
    *   `REQ-F-1` (Высокий): Система должна позволять администратору Atlas (далее "Админ") регистрироваться с использованием email и пароля.
    *   `REQ-F-2` (Высокий): Система должна позволять Админу аутентифицироваться с использованием email/пароля или через OAuth2.0 (Google, Yandex).
    *   `REQ-F-3` (Высокий): Админ должен иметь возможность создавать, просматривать, редактировать и удалять свои проекты.
    *   `REQ-F-4` (Высокий): Админ должен иметь возможность настраивать параметры проекта (имя, описание, URL для редиректа, настройки OAuth).
    *   `REQ-F-5` (Высокий): Система должна предоставлять уникальный ID для каждого проекта для использования при встраивании форм.
    *   `REQ-F-6` (Высокий): Система должна предоставлять возможность встраивания форм логина и регистрации для конечных пользователей (далее "Пользователь") в сторонние приложения через iframe.
    *   `REQ-F-7` (Высокий): Встроенные формы должны позволять Пользователю регистрироваться/аутентифицироваться через email/пароль или OAuth2.0 (если включено для проекта).
    *   `REQ-F-8` (Высокий): Система должна обеспечивать безопасный обмен данными (токены, данные пользователя) между iframe и родительским приложением через `postMessage`.
    *   `REQ-F-9` (Средний): Админ должен иметь возможность просматривать список Пользователей, зарегистрированных в его проекте.
    *   `REQ-F-10` (Средний): Админ должен иметь возможность изменять роль Пользователя в своем проекте (например, 'user', 'admin').
    *   `REQ-F-11` (Средний): Админ должен иметь возможность блокировать/разблокировать Пользователя в своем проекте.
    *   `REQ-F-12` (Высокий): Веб-интерфейс (панель Админа и встроенные формы) должен отображать уведомления об ошибках (например, при недоступности API, ошибках валидации, проблемах с OAuth).
    *   `REQ-F-13` (Средний): Админ должен иметь возможность включать/выключать OAuth для проекта и выбирать активных провайдеров (Google, Yandex).
*   **Нефункциональные требования:**
    *   `REQ-NF-1` (Высокий): Время ответа API для операций аутентификации (логин, регистрация, колбэк OAuth) не должно превышать 500 мс при средней нагрузке (~50 одновременных запросов).
    *   `REQ-NF-2` (Высокий): Интерфейс панели управления Админа и встраиваемых форм должен быть интуитивно понятным (соответствовать стандартным паттернам веб-приложений) и не требовать длительного обучения.
    *   `REQ-NF-3` (Средний): Система должна корректно отображаться и функционировать в последних версиях браузеров Google Chrome, Mozilla Firefox, Apple Safari.
    *   `REQ-NF-4` (Высокий): Доступность сервиса (uptime) в рамках прототипа должна быть не менее 99%.
    *   `REQ-NF-5` (Средний): Система (прототип) должна быть спроектирована для поддержки до 500 активных Пользователей (в сумме по всем проектам) без существенной деградации производительности (>1 сек на запрос).
    *   `REQ-NF-6` (Высокий): Должны использоваться безопасные методы аутентификации и передачи данных (HTTPS, JWT с подписью, безопасные флаги cookie если используются, проверка origin в postMessage, хеширование паролей Bcrypt).
    *   `REQ-NF-7` (Средний): Кодовая база должна быть модульной (разделение на роутеры, сервисы, модели в FastAPI; компоненты, страницы, сервисы в React) и содержать комментарии для ключевых или сложных участков кода.

**5. Концептуальное моделирование**

**5.1. Описание процесса построения инфологической модели**

Инфологическая модель была разработана на основе анализа основных сценариев использования сервиса Atlas. Были выделены ключевые сущности:
*   **Admins (Администраторы Atlas):** Субъекты, которые регистрируются в Atlas, создают проекты и управляют ими. Имеют `login`, `email`, `password` (хешированный, может быть null для OAuth), данные об OAuth-провайдере (`oauth_provider`, `oauth_user_id`), временные метки (`created_at`, `updated_at`, `last_login`).
*   **Projects (Проекты):** Сущности, создаваемые Администраторами. Каждый проект представляет собой конфигурацию аутентификации для одного стороннего приложения. Имеют уникальный `id` (UUID), `name`, `description`, `url` (для редиректа), `owner_id` (ссылка на Admins), настройки OAuth (`oauth_enabled`, `oauth_providers` в JSON), временные метки.
*   **Users (Конечные пользователи):** Субъекты, которые регистрируются или входят в стороннее приложение *через* формы Atlas, ассоциированные с конкретным проектом. Имеют `login`, `email`, `password` (хешированный, null для OAuth), `project_id` (ссылка на Projects), `role` (строка, например, 'user', 'admin' - роль *внутри проекта*), `status` (Enum: 'active', 'blocked'), данные об OAuth, временные метки.

Связи между сущностями:
*   Один `Admin` может владеть многими `Projects` (один-ко-многим).
*   Один `Project` принадлежит одному `Admin` (многие-к-одному).
*   Один `Project` может иметь много `Users` (один-ко-многим).
*   Один `User` принадлежит одному `Project` (многие-к-одному).

Эта модель была реализована с использованием SQLAlchemy ORM, код которой был предоставлен.

    **5.1.1. Диаграмма "сущность-связь" (ERD)**

**5.2. Пользовательские сценарии (User journeys)**

*   **Разделение ролей:**
    *   **Admin:** Пользователь сервиса Atlas, который настраивает аутентификацию для своих внешних приложений.
    *   **User:** Конечный пользователь внешнего приложения, который использует формы Atlas для входа или регистрации.
*   **Примеры сценариев:**
    *   **Сценарий 1 (Admin): Регистрация и создание проекта**
        1.  Admin переходит на сайт Atlas.
        2.  Выбирает опцию входа/регистрации через Google или Yandex.
        3.  Проходит аутентификацию на стороне провайдера.
        4.  Перенаправляется обратно в Atlas, где создается его учетная запись.
        5.  Admin переходит в раздел "Проекты" и нажимает "Создать проект".
        6.  Вводит Название, Описание, URL для редиректа своего приложения (куда перенаправлять User после успешного входа).
        7.  Настраивает опции OAuth (включает OAuth, выбирает Google/Yandex).
        8.  Сохраняет проект.
        9.  Копирует сгенерированный UUID проекта для интеграции в свое приложение.
    *   **Сценарий 2 (User): Регистрация в стороннем приложении через Atlas (iframe)**
        1.  User заходит на сайт приложения, интегрировавшего Atlas.
        2.  Нажимает кнопку "Регистрация".
        3.  На странице отображается iframe с формой регистрации Atlas.
        4.  User вводит email, пароль, подтверждение пароля.
        5.  Нажимает "Зарегистрироваться".
        6.  Atlas (внутри iframe) отправляет данные на свой бэкенд, создает User'a, связанного с project_id, и отправляет сообщение (`postMessage`) родительскому окну об успехе (`ATLAS_REGISTER_SUCCESS` с данными User'a).
        7.  Стороннее приложение получает сообщение, может сохранить данные User'a у себя и перенаправляет User'a на главную страницу приложения (или на URL, указанный Admin'ом).
    *   **Сценарий 3 (User): Вход в стороннее приложение через Atlas (OAuth)**
        1.  User заходит на сайт приложения, интегрировавшего Atlas.
        2.  Нажимает "Войти".
        3.  В iframe Atlas нажимает кнопку "Войти через Google".
        4.  Открывается окно Google для аутентификации.
        5.  User входит в Google.
        6.  Google перенаправляет обратно в Atlas (в iframe).
        7.  Atlas проверяет пользователя, генерирует JWT-токены и отправляет сообщение (`postMessage`) родительскому окну об успехе (`ATLAS_AUTH_SUCCESS` с токенами).
        8.  Стороннее приложение получает сообщение, сохраняет токены (например, в localStorage) и перенаправляет User'a на главную страницу приложения.
    *   **Сценарий 4 (Admin): Блокировка пользователя**
        1.  Admin входит в панель управления Atlas.
        2.  Выбирает нужный проект.
        3.  Переходит на вкладку "Пользователи".
        4.  Находит нужного User'a в списке.
        5.  Нажимает кнопку "Заблокировать" напротив User'a.
        6.  Система изменяет статус User'a на 'blocked'.
        7.  Заблокированный User больше не сможет войти через Atlas для этого проекта.

    *   **[Необходима информация]:** *Требуется подтверждение и, возможно, детализация сценариев. Нужны ли User Stories в формате "Как <роль>, я хочу <действие>, чтобы <цель>"?*

**6. Логическое моделирование данных**

**6.1. Описание процесса перехода к даталогической (реляционной) модели**

    *   **[Необходима информация]:** *Преобразование ERD в реляционную модель было прямым, так как использовалась ORM (SQLAlchemy). Каждая сущность стала таблицей. Атрибуты стали столбцами с соответствующими типами данных. Связи "один-ко-многим" реализованы через внешние ключи (FK) в таблицах на стороне "многих" (Projects.owner_id -> Admins.id, Users.project_id -> Projects.id). Связи "многие-ко-многим" в текущей модели отсутствуют. Модель, вероятно, соответствует 3NF, так как нет очевидных транзитивных зависимостей и все неключевые атрибуты зависят от первичного ключа. Необходимо формальное подтверждение уровня нормализации.*

    **6.1.1. Таблично-ссылочная диаграмма (TRD) с комментариями**
    *   **[Необходима информация]:** *Предоставьте диаграмму TRD, визуализирующую таблицы `admins`, `projects`, `users`, их столбцы, типы данных, PK и FK. Можно использовать инструменты типа dbdiagram.io или аналоги.*

**7. Логическое моделирование процессов**

**7.1. Основные сценарии (BPMN)**

    *   **[Необходима информация]:** *Представьте диаграммы BPMN 2.0 для ключевых сценариев (например, Сценарий 1 и Сценарий 3 из п. 5.2).*

**7.2. Частичная диаграмма потоков данных (DFD или аналоги)**

    *   **[Необходима информация]:** *Предоставьте диаграмму DFD (например, 0-го уровня, показывающую взаимодействие Atlas с Admin, User, OAuth Provider и Сторонним приложением) или DFD 1-го уровня для процесса аутентификации.*

**8. Физическое моделирование данных**

**8.1. Диаграмма схемы БД (с типами данных и ссылочной целостностью)**

    *   **[Необходима информация]:** *Предоставьте диаграмму физической схемы PostgreSQL, сгенерированную из ORM или DDL. Должны быть видны точные типы данных (VARCHAR, TIMESTAMP WITH TIME ZONE, INTEGER, BOOLEAN, JSON, ENUM), PK, FK, NOT NULL.*

**8.2. Дополнительные механизмы обеспечения целостности данных**

На основе предоставленного кода SQLAlchemy:
*   **Ограничения `UNIQUE`:**
    *   `admins.login`
    *   `admins.email`
    *   `users.login`
    *   `users.email`
*   **Ограничения `NOT NULL`:** На все поля, где `nullable=False`, включая:
    *   `admins.login`, `admins.email`, `admins.created_at`, `admins.updated_at`
    *   `projects.name`, `projects.description`, `projects.owner_id`, `projects.oauth_enabled`, `projects.created_at`, `projects.updated_at`
    *   `users.login`, `users.email`, `users.project_id`, `users.role`, `users.status`, `users.created_at`, `users.updated_at`
*   **Ограничения `FOREIGN KEY`:**
    *   `projects.owner_id` ссылается на `admins.id`
    *   `users.project_id` ссылается на `projects.id`
*   **Ограничения `ENUM` (через SQLAlchemyEnum):**
    *   `admins.oauth_provider`, `users.oauth_provider` (используют `OAuthProvider`)
    *   `users.status` (использует `UserStatus`)
*   **Значения по умолчанию (`default`, `server_default`):**
    *   `projects.id` (UUID)
    *   `projects.oauth_enabled` (False)
    *   `users.role` ("user")
    *   `users.status` (UserStatus.ACTIVE)
    *   `created_at`, `updated_at` (func.now())
*   **Автоматическое обновление (`onupdate`):**
    *   `updated_at` (func.now())

**8.3. DDL-код БД**

    *   **[Необходима информация]:** *Предоставьте полный DDL-скрипт PostgreSQL, который можно сгенерировать с помощью Alembic или напрямую из метаданных SQLAlchemy.*

**9. Построение приложения**

**9.1. Бизнес-логика тестового приложения**

*   Тестовое приложение имитирует сайт разработчика (например, TODO-лист или блог), который интегрирует Atlas для аутентификации своих пользователей.
*   **Реализованные сценарии:**
    *   Отображение страниц логина и регистрации, содержащих компонент Atlas.
    *   Передача `projectId` в iframe.
    *   Прослушивание событий `message` от iframe Atlas (`ATLAS_AUTH_SUCCESS`, `ATLAS_REGISTER_SUCCESS`, `ATLAS_IFRAME_HEIGHT`).
    *   При получении `ATLAS_AUTH_SUCCESS`: сохранение JWT-токенов (access, refresh) в `localStorage`.
    *   При получении `ATLAS_REGISTER_SUCCESS`: вызов API своего бэкенда для создания локальной записи пользователя.
    *   Управление состоянием "залогинен/не залогинен" на основе наличия токенов.
    *   Перенаправление пользователя на защищенные страницы после успешного входа(наличие токена в `localStorage`).
    *   Реализация выхода из системы (удаление токенов из `localStorage`).
    *   Использование access-токена для запросов к своему защищенному API.

    *   **[Необходима информация]:** *Требуется подтверждение реализованных сценариев в тестовом приложении.*

**9.2. Техническое описание тестового приложения**

*   **Технологии:** React  JS + Python(FastAPI) + PostgreSQL + Docker + Nginx.
*   **Ключевой компонент интеграции:** `AuthIframe`.
*   **Пример работающего приложения:** [https://todo.appweb.space/](https://todo.appweb.space/)


    *   **[Необходима информация]:** *Есть ли у тестового приложения свой бэкенд? Какие еще библиотеки используются?*

**9.3. UI-решения**

*   **Atlas (Панель Админа и встроенные формы):** Используется UI-библиотека Ant Design для большинства элементов интерфейса (кнопки, формы, таблицы, модальные окна и т.д.).
*   **Тестовое приложение:** Также использует UI-библиотеку Ant Design для элементов интерфейса.

    *   **[Необходима информация]:** *Предоставьте скриншоты ключевых экранов панели управления Atlas (список проектов, детали проекта со списком пользователей, настройки OAuth) и тестового приложения (страница логина/регистрации с iframe Atlas, защищенная страница после входа).*

**9.4. Примеры редактирования данных в БД**

*   **Пример 1: Изменение роли пользователя Админом через API**
    *   Админ в UI панели управления выбирает пользователя в списке проекта и выбирает новую роль ('user' или 'admin') в выпадающем списке или форме.
    *   UI отправляет PUT-запрос на эндпоинт `/projects/{project_id}/users/{user_id}/role` с телом `{"new_role": "admin"}`.
    *   Бэкенд (FastAPI, код предоставлен) выполняет проверку прав Админа, находит пользователя и обновляет поле `role` в таблице `users`. SQL (генерируемый SQLAlchemy): `UPDATE users SET role = 'admin' WHERE id = :user_id AND project_id = :project_id;`
*   **Пример 2: Создание проекта Админом через API**
    *   Админ в UI нажимает "Создать проект", заполняет форму (имя, описание, URL, настройки OAuth).
    *   UI отправляет POST-запрос на эндпоинт `/projects/` с данными проекта в теле.
    *   Бэкенд (FastAPI, код предоставлен) создает новую запись в таблице `projects`. SQL (генерируемый SQLAlchemy): `INSERT INTO projects (id, name, description, owner_id, url, oauth_enabled, oauth_providers, created_at, updated_at) VALUES (:id, :name, :description, :owner_id, :url, :oauth_enabled, :oauth_providers, NOW(), NOW()) RETURNING id;`
*   **Пример 3: Обновление проекта Админом через API** (Аналогично созданию, используется PUT /projects/{project_id} и SQL `UPDATE projects SET ... WHERE id = :project_id;`)
*   **Пример 4: Удаление проекта Админом через API** (Используется DELETE /projects/{project_id} и SQL `DELETE FROM projects WHERE id = :project_id;`)
*   **Пример 5: Обновление данных пользователя после входа через OAuth**
    *   После успешного колбэка от OAuth-провайдера, бэкенд Atlas находит или создает пользователя в таблице `users` и обновляет поля `last_login` и, возможно, `oauth_user_id` / `oauth_provider`, если это первый вход через этого провайдера. SQL (генерируемый SQLAlchemy): `UPDATE users SET last_login = NOW(), oauth_user_id = :oauth_user_id WHERE email = :email AND project_id = :project_id;`

    *   **[Необходима информация]:** *Предоставьте скриншоты соответствующих UI-форм из панели управления Atlas.*

**9.5. Запросы и отчеты (включая SQL)**

    *   **Пример 1: Получение списка проектов Админа (с количеством пользователей)**
        *   Эндпоинт: `GET /projects/` (код предоставлен).
        *   SQL (генерируемый SQLAlchemy, примерная структура):
          ```sql
          SELECT
              p.id, p.name, p.description, p.owner_id, p.url, p.oauth_enabled,
              count(u.id) AS user_count
          FROM projects p
          LEFT OUTER JOIN users u ON u.project_id = p.id
          WHERE p.owner_id = :current_admin_id
          GROUP BY p.id;
          ```
    *   **Пример 2: Получение деталей проекта (включая список пользователей)**
        *   Эндпоинт: `GET /projects/{project_id}` (код предоставлен).
        *   SQL (два запроса, примерная структура):
          ```sql
          -- Запрос 1: Получить детали проекта
          SELECT p.id, ..., count(u.id) AS user_count
          FROM projects p LEFT OUTER JOIN users u ON u.project_id = p.id
          WHERE p.id = :project_id AND p.owner_id = :current_admin_id
          GROUP BY p.id;
          -- Запрос 2: Получить пользователей проекта
          SELECT u.id, u.login, u.email, u.role, u.status, u.oauth_provider
          FROM users u
          WHERE u.project_id = :project_id;
          ```
    *   **Отчеты:** На данном этапе специфические отчеты (например, графики, статистика) не реализованы.

    *   **[Необходима информация]:** *Есть ли другие важные запросы? Планируются ли отчеты?*

**9.6. Артефакты юзабилити-тестирования**

*   Упоминалась оценка удобства интерфейса по принципам Нильсена.

    *   **[Необходима информация]:** *Предоставьте конкретные артефакты: результаты оценки по эвристикам Нильсена (например, таблица с оценками и комментариями по каждой эвристике), описание методики тестирования (кто проводил, на ком, какие сценарии проверялись), сводку полученной обратной связи от тестировщиков, описание изменений в UI/UX, внесенных по результатам тестирования.*

**10. Результаты функционального тестирования**

*   Проводилось ручное тестирование API через Swagger UI.
*   Проводилось ручное E2E-тестирование с использованием отдельного тестового веб-приложения (`https://todo.appweb.space/`) для проверки сценариев встраивания форм, регистрации и логина (email/пароль и OAuth).
*   (Предположительно) Использовался Pytest для юнит-тестов бэкенда.

    *   **[Необходима информация]:** *Предоставьте сводку результатов: количество выполненных тест-кейсов (ручных API, ручных E2E, автоматических юнит-тестов Pytest), процент успешных тестов, количество и критичность найденных и исправленных дефектов, отчеты о покрытии кода тестами (если измерялось).*

**11. Результаты юзабилити-тестирования**

    *   **[Необходима информация]:** *См. пункт 9.6. Предоставьте формализованные результаты тестирования удобства использования.*

**12. Заключение**

Проект Atlas успешно реализован в качестве MVP, демонстрирующего ключевые функциональные возможности. Система предоставляет встраиваемые формы аутентификации с поддержкой как традиционного входа по email и паролю, так и OAuth-авторизации через популярных провайдеров, включая Google и Yandex. Одновременно реализована административная панель, позволяющая управлять проектами и осуществлять базовый контроль над пользователями. Выбранный технологический стек, включающий FastAPI для бэкенда, React для фронтенда, PostgreSQL в качестве СУБД и Docker для контейнеризации, доказал свою эффективность для создания современного, производительного и масштабируемого веб-сервиса.

Проект особенно актуален для российского рынка, где существует устойчивый спрос на решения с интеграцией локальных OAuth-провайдеров и минимальными инфраструктурными требованиями. Проведенное функциональное тестирование через тестовое приложение подтвердило корректную работу всех ключевых интеграционных сценариев. В рамках тестирования особое внимание уделялось проверке взаимодействия между встраиваемыми формами и родительскими приложениями через безопасный обмен данными с использованием postMessage.

Дальнейшее развитие проекта в контексте магистерской диссертации будет сосредоточено на нескольких стратегических направлениях. Планируется проведение глубокого рефакторинга кодовой базы с возможным переходом к микросервисной архитектуре для улучшения масштабируемости и поддерживаемости системы. Функциональное расширение будет включать добавление поддержки новых OAuth-провайдеров, внедрение более гибких систем управления доступом (RBAC/ABAC), возможность назначения нескольких администраторов на проект, реализацию двухфакторной аутентификации и инструментов кастомизации внешнего вида форм.

Особое внимание будет уделено вопросам безопасности: запланированы регулярные аудиты безопасности, внедрение дополнительных защитных механизмов и постоянный мониторинг уязвимостей. Для обеспечения стабильной работы растущего числа пользователей предусмотрены работы по оптимизации производительности и повышению отказоустойчивости системы. Параллельно будет разработана комплексная система автоматизированного тестирования, включающая модульные, интеграционные и end-to-end тесты, что позволит поддерживать высокое качество кода при активной разработке новых функций.

**13. Приложения (например, Ссылки)**

*   **Тестовое приложение:** [https://todo.appweb.space/](https://todo.appweb.space/)
*   **[Необходима информация]:** *Добавьте ссылки на:*
    *   *Репозиторий GitHub (если он публичный или будет сделан таковым).*
    *   *Swagger/OpenAPI документацию API.*
    *   *Ключевые используемые библиотеки (Ant Design, FastAPI, SQLAlchemy и т.д.).*
    *   *Источники статистических данных или исследований (если использовались для обоснования актуальности).*

---

Пожалуйста, просмотрите обновленный документ и предоставьте недостающую информацию, чтобы сделать его максимально полным и точным.